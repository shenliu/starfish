<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta http-equiv="pragma" content="no-cache" />
		<meta http-equiv="cache-control" content="no-cache" />
		<meta http-equiv="expires" content="0" />
		<meta name="robots" content="all" />
		<meta name="author" content="bonjour.shen@gmail.com, shen" />
		
        <title>test_class</title>
        <link rel="stylesheet" type="text/css" href="../css/common.css" />
        <!--[if IE]>
			<link rel="stylesheet" type="text/css" href="../css/ie.css" />
		<![endif]-->
		
		<script type="text/javascript" src="../src/sf_core.js"></script>
		<script type="text/javascript" src="../src/sf_class.js"></script>
    </head>
    <body>
    	<div id="d1">test_class</div>
    	<script type="text/javascript">
    		window.$ = starfish.$;
    		alert("begin...");
    		
    		// 父类
	     	function Person(name) {
	  			this.name = name;
			}
	
			// 实例方法
			Person.prototype.getName = function() {
	  			return this.name;
			}
			
			// 子类
			function Author(name, books) {
				// 调用父类 构造函数
	  			Author.superclass.constructor.call(this, name);
	  			this.books = books;
			}
			
			// 继承
			starfish.clazz.extend(Author, Person);
			
			// 子类实例方法
			Author.prototype.getBooks = function() {
	  			return this.books;
			};
			
			// 复写父类方法
			Author.prototype.getName = function() {
	  			var name = Author.superclass.getName.call(this);
	  			return name + ', Author of ' + this.getBooks().join(', ');
			};
			
			var author = new Author("shen", ["abc", "xyz"]);
			alert(author.getName());
			alert(author.getBooks());
			alert(Person.prototype.getName.apply(author));
			
			alert(starfish.getType(author));
			
			alert("finish...");
    	</script>
    </body>
</html>
